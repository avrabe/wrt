use std::{fs, io::Write, path::Path};

use anyhow::Result;
use clap::Parser;
use regex::Regex;
use walkdir::WalkDir;
use xshell::Shell;

#[derive(Debug, Parser, Clone)]
pub struct GenerateSourceNeedsArgs {}

fn is_excluded(path: &Path, workspace_root: &Path) -> bool {
    let excluded_dirs = [
        "target",
        ".git",
        ".github",
        ".vscode",
        ".idea",
        ".cargo",
        ".zephyr-venv",
        ".zephyrproject",
        "bazel-bin",
        "bazel-out",
        "bazel-testlogs",
        "bazel-wrt2",
        "docs/source/conf.py",
        // To avoid xtask itself or other docs files
        "docs",
        "xtask",
    ];
    let excluded_components = ["test", "tests", "testsuite", "examples", "benches", "fuzz"];

    path.strip_prefix(workspace_root).map_or(true, |relative_path| {
        let path_str = relative_path.to_string_lossy().to_lowercase();

        if excluded_dirs.iter().any(|ex_dir| relative_path.starts_with(ex_dir)) {
            return true;
        }

        if relative_path.components().any(|comp| {
            let comp_str = comp.as_os_str().to_string_lossy().to_lowercase();
            excluded_components.contains(&comp_str.as_ref())
        }) {
            return true;
        }

        // Specifically exclude files within any "test", "tests", etc. directory
        // component e.g. wrt-runtime/src/tests/some_test.rs
        if path_str.contains("/test/")
            || path_str.contains("/tests/")
            || path_str.contains("/testsuite/")
            || path_str.contains("/examples/")
            || path_str.contains("/benches/")
            || path_str.contains("/fuzz/")
        {
            return true;
        }

        false
    })
}

pub fn run_generate_source_needs(_args: GenerateSourceNeedsArgs, sh: &Shell) -> Result<()> {
    println!("Generating source requirements RST file...");

    let workspace_root = sh.current_dir();
    let output_dir = workspace_root.join("docs/source/implementation");
    let output_file_path = output_dir.join("source_requirements.rst");

    fs::create_dir_all(&output_dir)?;

    let mut rst_content = String::new();
    rst_content.push_str("Source File Implementations\n");
    rst_content.push_str("===========================\n\n");
    rst_content.push_str(
        "This file is auto-generated by `cargo xtask generate-source-needs`. Do not edit \
         manually.\n\n",
    );

    let req_id_regex = Regex::new(r"// SW-REQ-ID:").unwrap();
    let req_na_regex = Regex::new(r"// SW-REQ-ID:\s*N/A").unwrap();

    let mut found_files_count = 0;

    for entry in WalkDir::new(&workspace_root)
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_file())
        .filter(|e| e.path().extension().map_or(false, |ext| ext == "rs"))
        .filter(|e| !is_excluded(e.path(), &workspace_root))
    {
        let file_path = entry.path();
        if let Ok(content) = fs::read_to_string(file_path) {
            let has_req_id = req_id_regex.is_match(&content);
            if !has_req_id {
                continue;
            }

            // Check if all SW-REQ-IDs are N/A
            let mut all_na = true;
            let mut has_any_req_id_line = false;
            for line in content.lines() {
                if line.trim_start().starts_with("// SW-REQ-ID:") {
                    has_any_req_id_line = true;
                    if !req_na_regex.is_match(line) {
                        all_na = false;
                        break;
                    }
                }
            }

            if !has_any_req_id_line || all_na {
                // println!("Skipping file with only N/A or no SW-REQ-ID lines: {:?}",
                // file_path);
                continue;
            }

            found_files_count += 1;

            // 1. SRC ID: SRC_WRT_TYPES_SRC_LIB
            let relative_to_ws = file_path.strip_prefix(&workspace_root).unwrap_or(file_path);
            let src_id = format!(
                "SRC_{}",
                relative_to_ws
                    .to_string_lossy()
                    .replace(".rs", "")
                    .replace(['/', '-'], "_")
                    .to_uppercase()
            );

            // 2. :file: path relative from output_file_path.parent() to file_path
            // Example: output_file_path.parent() = /ws/docs/source/implementation
            //          file_path                 = /ws/wrt-foundation/src/lib.rs
            //          result                    = ../../wrt-foundation/src/lib.rs
            let path_for_file_attr = pathdiff::diff_paths(file_path, output_dir.as_path())
                .ok_or_else(|| {
                    anyhow::anyhow!(
                        "Failed to calculate relative path for {:?} from {:?}",
                        file_path,
                        output_dir
                    )
                })?;

            rst_content.push_str(&format!(".. src:: {}\n", relative_to_ws.display())); // Title for the need
            rst_content.push_str(&format!("   :id: {}\n", src_id));
            rst_content.push_str(&format!("   :file: {}\n", path_for_file_attr.to_string_lossy()));
            rst_content.push_str("   :realizes: =extract_reqs()\n\n");
        }
    }

    if found_files_count == 0 {
        rst_content.push_str("No source files with relevant SW-REQ-ID found.\n");
    }

    let mut file = fs::File::create(&output_file_path)?;
    file.write_all(rst_content.as_bytes())?;

    println!(
        "Successfully generated {} with {} source file entries.",
        output_file_path.display(),
        found_files_count
    );

    Ok(())
}
