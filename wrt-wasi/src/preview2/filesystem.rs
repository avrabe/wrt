//! WASI filesystem interface implementation
//!
//! Implements the `wasi:filesystem` interface using WRT's platform abstractions
//! and proven patterns from wrt-host and wrt-platform.

use crate::prelude::*;
use wrt_platform::filesystem::PlatformFilesystem;
use wrt_component::values::Value;
use core::any::Any;

/// WASI filesystem read operation
///
/// Implements `wasi:filesystem/types.read` using WRT platform abstractions
pub fn wasi_filesystem_read(
    _target: &mut dyn Any,
    args: Vec<Value>,
) -> Result<Vec<Value>> {
    // Extract file descriptor from arguments
    let fd = extract_file_descriptor(&args)?;
    
    // Validate the file descriptor exists and is readable
    // In a real implementation, this would access the resource manager
    // For now, provide a basic implementation
    
    // Use platform filesystem abstraction
    let filesystem = PlatformFilesystem::new();
    
    // Read operation would go here
    // For now, return empty data as placeholder
    let data = Vec::new();
    
    // Return as WASI list<u8>
    Ok(vec![Value::List(data.into_iter().map(Value::U8).collect())])
}

/// WASI filesystem write operation
///
/// Implements `wasi:filesystem/types.write` using WRT platform abstractions
pub fn wasi_filesystem_write(
    _target: &mut dyn Any,
    args: Vec<Value>,
) -> Result<Vec<Value>> {
    // Extract file descriptor and data from arguments
    let fd = extract_file_descriptor(&args)?;
    let data = extract_byte_data(&args, 1)?;
    
    // Validate the file descriptor exists and is writable
    // In a real implementation, this would access the resource manager
    
    // Use platform filesystem abstraction
    let filesystem = PlatformFilesystem::new();
    
    // Write operation would go here
    // For now, return bytes written as data length
    let bytes_written = data.len() as u64;
    
    // Return bytes written
    Ok(vec![Value::U64(bytes_written)])
}

/// WASI filesystem open operation
///
/// Implements `wasi:filesystem/types.open-at` for opening files
pub fn wasi_filesystem_open_at(
    _target: &mut dyn Any,
    args: Vec<Value>,
) -> Result<Vec<Value>> {
    // Extract directory fd and path
    let dir_fd = extract_file_descriptor(&args)?;
    let path = extract_string(&args, 1)?;
    
    // Validate directory descriptor
    // Check path is allowed by capabilities
    
    // Use platform filesystem to open file
    let filesystem = PlatformFilesystem::new();
    
    // For now, return a placeholder file descriptor
    let new_fd = 42u32; // Would be generated by resource manager
    
    Ok(vec![Value::U32(new_fd)])
}

/// WASI filesystem metadata operation
///
/// Implements `wasi:filesystem/types.stat` for file metadata
pub fn wasi_filesystem_stat(
    _target: &mut dyn Any,
    args: Vec<Value>,
) -> Result<Vec<Value>> {
    let fd = extract_file_descriptor(&args)?;
    
    // Get file metadata using platform abstraction
    let filesystem = PlatformFilesystem::new();
    
    // Return file metadata as WASI descriptor-stat record
    // For now, return placeholder metadata
    let metadata = create_file_metadata_record()?;
    
    Ok(vec![metadata])
}

/// WASI filesystem read directory operation
///
/// Implements `wasi:filesystem/types.read-directory` for directory listing
pub fn wasi_filesystem_read_directory(
    _target: &mut dyn Any,
    args: Vec<Value>,
) -> Result<Vec<Value>> {
    let dir_fd = extract_file_descriptor(&args)?;
    
    // Read directory contents using platform abstraction
    let filesystem = PlatformFilesystem::new();
    
    // Return directory entries
    // For now, return empty directory
    let entries = Vec::new();
    
    Ok(vec![Value::List(entries)])
}

/// Helper function to extract file descriptor from arguments
fn extract_file_descriptor(args: &[Value]) -> Result<u32> {
    if args.is_empty() {
        return Err(Error::new(
            ErrorCategory::Parse,
            codes::WASI_INVALID_FD,
            kinds::WasiResourceError("Missing file descriptor argument")
        ));
    }
    
    match &args[0] {
        Value::U32(fd) => Ok(*fd),
        Value::S32(fd) => {
            if *fd < 0 {
                Err(Error::new(
                    ErrorCategory::Parse,
                    codes::WASI_INVALID_FD,
                    kinds::WasiResourceError("Invalid negative file descriptor")
                ))
            } else {
                Ok(*fd as u32)
            }
        }
        _ => Err(Error::new(
            ErrorCategory::Parse,
            codes::WASI_INVALID_FD,
            kinds::WasiResourceError("Invalid file descriptor type")
        )),
    }
}

/// Helper function to extract byte data from arguments
fn extract_byte_data(args: &[Value], index: usize) -> Result<Vec<u8>> {
    if args.len() <= index {
        return Err(Error::new(
            ErrorCategory::Parse,
            codes::WASI_INVALID_FD,
            kinds::WasiResourceError("Missing data argument")
        ));
    }
    
    match &args[index] {
        Value::List(items) => {
            let mut data = Vec::new();
            for item in items {
                match item {
                    Value::U8(byte) => data.push(*byte),
                    _ => return Err(Error::new(
                        ErrorCategory::Parse,
                        codes::WASI_INVALID_FD,
                        kinds::WasiResourceError("Invalid byte data")
                    )),
                }
            }
            Ok(data)
        }
        _ => Err(Error::new(
            ErrorCategory::Parse,
            codes::WASI_INVALID_FD,
            kinds::WasiResourceError("Invalid data type")
        )),
    }
}

/// Helper function to extract string from arguments
fn extract_string(args: &[Value], index: usize) -> Result<String> {
    if args.len() <= index {
        return Err(Error::new(
            ErrorCategory::Parse,
            codes::WASI_INVALID_FD,
            kinds::WasiResourceError("Missing string argument")
        ));
    }
    
    match &args[index] {
        Value::String(s) => Ok(s.clone()),
        _ => Err(Error::new(
            ErrorCategory::Parse,
            codes::WASI_INVALID_FD,
            kinds::WasiResourceError("Invalid string type")
        )),
    }
}

/// Create file metadata record for WASI
fn create_file_metadata_record() -> Result<Value> {
    // Create a WASI descriptor-stat record
    // This would contain file type, size, timestamps, etc.
    // For now, return a basic record structure
    
    let metadata_fields = vec![
        ("type".to_string(), Value::U8(1)), // Regular file
        ("size".to_string(), Value::U64(0)), // File size
        ("data-access-timestamp".to_string(), Value::U64(0)), // Access time
        ("data-modification-timestamp".to_string(), Value::U64(0)), // Modification time
        ("status-change-timestamp".to_string(), Value::U64(0)), // Status change time
    ];
    
    Ok(Value::Record(metadata_fields))
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_extract_file_descriptor() -> Result<()> {
        let args = vec![Value::U32(42)];
        let fd = extract_file_descriptor(&args)?;
        assert_eq!(fd, 42);
        
        let args = vec![Value::S32(24)];
        let fd = extract_file_descriptor(&args)?;
        assert_eq!(fd, 24);
        
        // Test negative fd
        let args = vec![Value::S32(-1)];
        let result = extract_file_descriptor(&args);
        assert!(result.is_err());
        
        Ok(())
    }
    
    #[test]
    fn test_extract_byte_data() -> Result<()> {
        let data = vec![Value::U8(1), Value::U8(2), Value::U8(3)];
        let args = vec![Value::U32(42), Value::List(data)];
        
        let bytes = extract_byte_data(&args, 1)?;
        assert_eq!(bytes, vec![1, 2, 3]);
        
        Ok(())
    }
    
    #[test]
    fn test_extract_string() -> Result<()> {
        let args = vec![Value::U32(42), Value::String("test.txt".to_string())];
        let path = extract_string(&args, 1)?;
        assert_eq!(path, "test.txt");
        
        Ok(())
    }
    
    #[test] 
    fn test_wasi_filesystem_operations() -> Result<()> {
        // Test read operation
        let args = vec![Value::U32(1)];
        let result = wasi_filesystem_read(&mut (), args)?;
        assert_eq!(result.len(), 1);
        
        // Test write operation
        let data = vec![Value::U8(1), Value::U8(2), Value::U8(3)];
        let args = vec![Value::U32(1), Value::List(data)];
        let result = wasi_filesystem_write(&mut (), args)?;
        assert_eq!(result.len(), 1);
        if let Value::U64(bytes_written) = &result[0] {
            assert_eq!(*bytes_written, 3);
        }
        
        Ok(())
    }
}