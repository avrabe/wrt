# Workflow for deploying Sphinx documentation to GitHub Pages
name: Deploy Documentation to Pages

on:
  # Runs on pushes targeting the default branch or tags
  push:
    branches: ["main"]
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build and deploy (leave empty for automatic detection)'
        required: false
        default: ''

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # We need history to get tags
          fetch-depth: 0
      
      - name: Setup Dagger CLI
        run: |
          cd /usr/local/bin # Or another directory in PATH
          curl -L https://dl.dagger.io/dagger/install.sh | sudo sh
          dagger version
          
      - name: Setup Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: nightly # Ensure this matches what xtask/Dagger pipeline might expect
          override: true
          components: llvm-tools-preview # if needed by llvm-cov

      - name: Check if just is available
        id: check-just
        run: |
            if command -v just &> /dev/null; then
              echo "JUST_INSTALLED=true" >> $GITHUB_ENV
              echo "Just is already installed"
            else
              echo "JUST_INSTALLED=false" >> $GITHUB_ENV
              echo "Just needs to be installed"
            fi
            
      - name: Install just
        if: env.JUST_INSTALLED != 'true'
        run: cargo install just --locked
        
      - name: Get versions to build
        id: get-versions
        run: |
          VERSIONS_STRING=""
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSIONS_STRING="${{ github.event.inputs.version }}"
            echo "::notice::Building specific version(s) from input: $VERSIONS_STRING"
          else
            echo "::notice::Building docs for 'main' and all Git tags."
            TAGS=$(git tag --sort=-v:refname)
            VERSIONS_STRING="main"
            for TAG_NAME in $TAGS; do
              VERSIONS_STRING="$VERSIONS_STRING $TAG_NAME"
            done
          fi
          UNIQUE_VERSIONS=$(echo "$VERSIONS_STRING" | xargs -n1 | sort -u | xargs)
          echo "VERSIONS_TO_BUILD=$UNIQUE_VERSIONS" >> $GITHUB_ENV
          echo "Final list of versions to build: $UNIQUE_VERSIONS"

      - name: Build documentation via Dagger and xtask
        run: |
          echo "Building documentation for versions: ${{ env.VERSIONS_TO_BUILD }}"
          # Ensure xtask is compiled
          cargo build --package xtask
          # Run the Dagger pipeline via xtask
          # The xtask command will handle connecting to Dagger and running the pipeline.
          # Output will be in ./docs_artifact (default or as specified)
          ./target/debug/xtask publish-docs-dagger --versions "${{ env.VERSIONS_TO_BUILD }}" --output-dir ./docs_artifact_final
        env:
          # DAGGER_LOG_FORMAT: plain # Optional: for cleaner logs in CI
          RUST_LOG: info # Optional: set log level for xtask/dagger-rs logs
          # If your Dagger pipeline needs access to GitHub token for private repos, etc.
          # GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Dagger often picks this up via docker credentials

      - name: Setup Pages
        uses: actions/configure-pages@v5
        
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './docs_artifact_final' # Path where Dagger pipeline (via xtask) exports the final result
          
  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
