//! Context utilities for error handling
//!
//! This module provides utilities for adding contextual information to errors.

#[cfg(feature = "std")]
extern crate std;

#[cfg(all(not(feature = "std"), feature = "alloc"))]
extern crate alloc;

// Use alloc for formatting if std is not enabled
#[cfg(all(not(feature = "std"), feature = "alloc"))]
use alloc::format;

// Use std for formatting if std is enabled
#[cfg(feature = "std")]
use std::format;

#[cfg(feature = "alloc")]
use super::Error;
#[cfg(feature = "alloc")]
use core::fmt::Display;

/// Provides the `context` method for `Result`.
///
/// This trait is only available when the `alloc` feature is enabled.
#[cfg(feature = "alloc")]
pub trait ResultExt<T, E> {
    /// Wraps the error value with additional context.
    ///
    /// # Errors
    ///
    /// If the original `Result` is an `Err`, this function returns a new `wrt_error::Error`
    /// wrapping the original error and prepending the provided context to its message.
    fn context<C>(self, context: C) -> core::result::Result<T, Error>
    where
        C: Display + Send + Sync + 'static;

    /// Wraps the error value with context generated by a closure.
    ///
    /// # Errors
    ///
    /// If the original `Result` is an `Err`, this function returns a new `wrt_error::Error`
    /// wrapping the original error and prepending the context (from the closure) to its message.
    fn with_context<C, F>(self, f: F) -> core::result::Result<T, Error>
    where
        C: Display + Send + Sync + 'static,
        F: FnOnce() -> C;

    /// Wraps the error value with a key-value pair as context.
    ///
    /// # Errors
    ///
    /// If the original `Result` is an `Err`, this function returns a new `wrt_error::Error`
    /// wrapping the original error and prepending the key-value pair to its message.
    fn with_key_value<K, V>(self, key: K, value: V) -> core::result::Result<T, Error>
    where
        K: Display,
        V: Display;
}

#[cfg(feature = "alloc")]
impl<T, E> ResultExt<T, E> for core::result::Result<T, E>
where
    E: Into<Error>,
{
    fn context<C>(self, context: C) -> core::result::Result<T, Error>
    where
        C: Display + Send + Sync + 'static,
    {
        match self {
            Ok(value) => Ok(value),
            Err(error) => {
                let error = error.into();
                Err(Error::new(
                    error.category,
                    error.code,
                    format!("{}: {}", context, error.message),
                ))
            }
        }
    }

    fn with_context<C, F>(self, f: F) -> core::result::Result<T, Error>
    where
        C: Display + Send + Sync + 'static,
        F: FnOnce() -> C,
    {
        match self {
            Ok(value) => Ok(value),
            Err(error) => {
                let error = error.into();
                Err(Error::new(error.category, error.code, format!("{}: {}", f(), error.message)))
            }
        }
    }

    fn with_key_value<K, V>(self, key: K, value: V) -> core::result::Result<T, Error>
    where
        K: Display,
        V: Display,
    {
        match self {
            Ok(value) => Ok(value),
            Err(error) => {
                let error = error.into();
                Err(Error::new(
                    error.category,
                    error.code,
                    format!("{}: {} - {}", key, value, error.message),
                ))
            }
        }
    }
}

#[cfg(all(feature = "std", feature = "alloc"))]
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        // In std context, we could potentially convert the ErrorSource trait object to std::error::Error
        // But we would need to ensure ErrorSource extends std::error::Error for this to work
        // Clippy: unnecessary_lazy_evaluations (previously option_map_or_none)
        self.source.as_ref().and({
            // This is a bit of a hack since we can't directly downcast the trait object
            // without knowing the concrete type, and we don't have a direct way to convert
            // a dyn ErrorSource to a dyn std::error::Error
            None
        })
    }
}
